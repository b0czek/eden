/**
 * Event Type Generator
 *
 * Extracts event declarations and generates event type interfaces.
 */

import { ClassDeclaration, Node, SyntaxKind } from "ts-morph";
import {
  replaceTypesWithInlineImports,
  extractDocs,
  generateHeader,
  namespaceToInterfaceName,
} from "./utils";

export interface EventInfo {
  namespace: string;
  eventName: string;
  payloadType: string;
  docs: string[];
}

export interface NamespaceEvents {
  namespace: string;
  interfaceName: string;
  events: Array<{ eventName: string; payloadType: string; docs: string[] }>;
}

/**
 * Extract event declarations from a class
 */
export function extractEventDeclarations(
  classDec: ClassDeclaration,
  namespace: string,
): EventInfo[] {
  const events: EventInfo[] = [];
  let eventsInterfaceName: string | null = null;

  // Check decorator arguments for events interface
  const namespaceDecorator = classDec.getDecorator("EdenNamespace");
  if (namespaceDecorator) {
    const args = namespaceDecorator.getArguments();
    if (args.length > 1 && Node.isObjectLiteralExpression(args[1])) {
      const eventsProperty = args[1].getProperty("events");
      if (eventsProperty && Node.isPropertyAssignment(eventsProperty)) {
        const initializer = eventsProperty.getInitializer();
        if (initializer && Node.isStringLiteral(initializer)) {
          eventsInterfaceName = initializer.getLiteralText();
        }
      }
    }
  }

  // Extract events interface from extends EdenEmitter<InterfaceName>
  if (!eventsInterfaceName) {
    const heritageClauses = classDec.getHeritageClauses();
    for (const clause of heritageClauses) {
      if (clause.getToken() === SyntaxKind.ExtendsKeyword) {
        for (const type of clause.getTypeNodes()) {
          const expression = type.getExpression();
          if (
            Node.isIdentifier(expression) &&
            expression.getText() === "EdenEmitter"
          ) {
            const typeArgs = type.getTypeArguments();
            if (typeArgs.length > 0) {
              const typeArg = typeArgs[0];
              if (Node.isTypeReference(typeArg)) {
                eventsInterfaceName = typeArg.getTypeName().getText();
              }
            }
          }
        }
      }
    }
  }

  // If we found an events interface name, find the interface definition
  if (eventsInterfaceName) {
    const sourceFile = classDec.getSourceFile();
    const interfaceDec = sourceFile.getInterface(eventsInterfaceName);

    if (interfaceDec) {
      interfaceDec.getProperties().forEach((prop) => {
        const nameNode = prop.getNameNode();
        if (Node.isStringLiteral(nameNode) || Node.isIdentifier(nameNode)) {
          const eventName = prop.getName();

          let cleanEventName = eventName;
          if (cleanEventName.startsWith('"') && cleanEventName.endsWith('"')) {
            cleanEventName = cleanEventName.slice(1, -1);
          } else if (
            cleanEventName.startsWith("'") &&
            cleanEventName.endsWith("'")
          ) {
            cleanEventName = cleanEventName.slice(1, -1);
          }

          let payloadType = "any";
          const typeNode = prop.getTypeNode();
          if (typeNode) {
            payloadType = typeNode.getText();
          }

          events.push({
            namespace,
            eventName: cleanEventName,
            payloadType,
            docs: extractDocs(prop),
          });
        }
      });
    }
  }

  return events;
}

/**
 * Group events by namespace
 */
export function groupEventsByNamespace(
  allEvents: EventInfo[],
): NamespaceEvents[] {
  const eventNamespaceMap = new Map<string, NamespaceEvents>();

  allEvents.forEach((evt) => {
    if (!eventNamespaceMap.has(evt.namespace)) {
      eventNamespaceMap.set(evt.namespace, {
        namespace: evt.namespace,
        interfaceName: namespaceToInterfaceName(evt.namespace, "Events"),
        events: [],
      });
    }
    eventNamespaceMap.get(evt.namespace)!.events.push({
      eventName: evt.eventName,
      payloadType: evt.payloadType,
      docs: evt.docs,
    });
  });

  return Array.from(eventNamespaceMap.values());
}

/**
 * Generate TypeScript event interface code
 */
export function generateEventsCode(
  namespaceEvents: NamespaceEvents[],
  exportedTypes: Set<string>,
): string {
  const lines: string[] = generateHeader(
    "This file is automatically generated by scripts/codegen",
  );

  // Generate interface for each namespace
  namespaceEvents.forEach((ns, index) => {
    lines.push("/**");
    lines.push(
      ` * ${ns.interfaceName} - Events for the "${ns.namespace}" namespace`,
    );
    lines.push(" */");
    lines.push(`export interface ${ns.interfaceName} {`);

    ns.events.forEach((evt) => {
      if (evt.docs.length > 0) {
        lines.push("  /**");
        evt.docs.forEach((doc) => {
          lines.push(`   * ${doc.replace(/\n/g, "\n   * ")}`);
        });
        lines.push("   */");
      }

      const payloadType = replaceTypesWithInlineImports(
        evt.payloadType,
        exportedTypes,
      );
      lines.push(`  "${ns.namespace}/${evt.eventName}": ${payloadType};`);
    });

    lines.push("}");
    if (index < namespaceEvents.length - 1) {
      lines.push("");
    }
  });

  // Generate AppEvents interface
  lines.push("");
  lines.push("/**");
  lines.push(" * Global event map - merge all event namespaces");
  lines.push(" */");

  if (namespaceEvents.length > 0) {
    const allInterfaces = namespaceEvents
      .map((ns) => ns.interfaceName)
      .join(", ");
    lines.push(`export interface AppEvents extends ${allInterfaces} {}`);
  } else {
    lines.push("export interface AppEvents {}");
  }

  return lines.join("\n") + "\n";
}
