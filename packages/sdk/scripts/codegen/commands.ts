/**
 * Command Type Generator
 *
 * Extracts @EdenHandler decorators and generates command type interfaces.
 */

import { Project, ClassDeclaration, Node, SyntaxKind } from "ts-morph";
import * as path from "path";
import {
  replaceTypesWithInlineImports,
  extractDocs,
  generateHeader,
  namespaceToInterfaceName,
} from "./utils";

export interface CommandInfo {
  namespace: string;
  command: string;
  argsType: string;
  returnType: string;
  docs: string[];
}

export interface NamespaceCommands {
  namespace: string;
  interfaceName: string;
  commands: Array<{
    command: string;
    argsType: string;
    returnType: string;
    docs: string[];
  }>;
}

/**
 * Extract command handlers from a class
 */
export function extractCommandHandlers(
  classDec: ClassDeclaration,
  namespace: string,
): CommandInfo[] {
  const commands: CommandInfo[] = [];

  classDec.getMethods().forEach((method) => {
    const commandDecorator = method.getDecorator("EdenHandler");
    if (commandDecorator) {
      const args = commandDecorator.getArguments();
      if (args.length > 0 && Node.isStringLiteral(args[0])) {
        const commandName = args[0].getLiteralText();

        // Extract argument type from first parameter
        let argsType = "Record<string, never>";
        const params = method.getParameters();
        if (params.length > 0) {
          const param = params[0];
          const typeNode = param.getTypeNode();
          if (typeNode) {
            let rawType = typeNode.getText();

            // Filter out properties starting with underscore (like _callerAppId)
            argsType = rawType
              .replace(/[;,]\s*_\w+\??\s*:\s*[^;,}]+/g, "")
              .replace(/{\s*_\w+\??\s*:\s*[^;,}]+\s*[;,]?\s*/g, "{ ")
              .replace(/[;,]\s*}/g, " }")
              .trim();
          }
        }

        // Extract return type
        let returnType = "any";
        const returnTypeNode = method.getReturnTypeNode();
        if (returnTypeNode) {
          const type = returnTypeNode.getType();
          const symbol = type.getSymbol();
          if (symbol && symbol.getName() === "Promise") {
            const typeArgs = type.getTypeArguments();
            if (typeArgs.length > 0) {
              if (Node.isTypeReference(returnTypeNode)) {
                const typeArgsNodes = returnTypeNode.getTypeArguments();
                if (typeArgsNodes.length > 0) {
                  returnType = typeArgsNodes[0].getText();
                } else {
                  returnType = "void";
                }
              } else {
                const typeText = returnTypeNode.getText();
                const match = typeText.match(/Promise<(.+)>/);
                if (match) {
                  returnType = match[1];
                } else {
                  returnType = typeText;
                }
              }
            }
          } else {
            returnType = returnTypeNode.getText();
          }
        }

        commands.push({
          namespace,
          command: commandName,
          argsType,
          returnType,
          docs: extractDocs(method),
        });
      }
    }
  });

  return commands;
}

/**
 * Group commands by namespace
 */
export function groupCommandsByNamespace(
  allCommands: CommandInfo[],
): NamespaceCommands[] {
  const namespaceMap = new Map<string, NamespaceCommands>();

  allCommands.forEach((cmd) => {
    if (!namespaceMap.has(cmd.namespace)) {
      namespaceMap.set(cmd.namespace, {
        namespace: cmd.namespace,
        interfaceName: namespaceToInterfaceName(cmd.namespace, "Commands"),
        commands: [],
      });
    }
    namespaceMap.get(cmd.namespace)!.commands.push({
      command: cmd.command,
      argsType: cmd.argsType,
      returnType: cmd.returnType,
      docs: cmd.docs,
    });
  });

  return Array.from(namespaceMap.values());
}

/**
 * Generate TypeScript interface code for commands
 */
export function generateCommandsCode(
  namespaceCommands: NamespaceCommands[],
  exportedTypes: Set<string>,
): string {
  const lines: string[] = generateHeader(
    "This file is automatically generated by scripts/codegen",
  );

  // Generate interface for each namespace
  namespaceCommands.forEach((ns, index) => {
    lines.push("/**");
    lines.push(
      ` * ${ns.interfaceName} - Commands for the "${ns.namespace}" namespace`,
    );
    lines.push(" */");
    lines.push(`export interface ${ns.interfaceName} {`);

    ns.commands.forEach((cmd) => {
      if (cmd.docs.length > 0) {
        lines.push("  /**");
        cmd.docs.forEach((doc) => {
          lines.push(`   * ${doc.replace(/\n/g, "\n   * ")}`);
        });
        lines.push("   */");
      }

      const argsType = replaceTypesWithInlineImports(
        cmd.argsType,
        exportedTypes,
      );
      const returnType = replaceTypesWithInlineImports(
        cmd.returnType,
        exportedTypes,
      );

      lines.push(`  "${ns.namespace}/${cmd.command}": {`);
      lines.push(`    args: ${argsType};`);
      lines.push(`    response: ${returnType};`);
      lines.push(`  };`);
    });

    lines.push("}");
    if (index < namespaceCommands.length - 1) {
      lines.push("");
    }
  });

  // Generate CommandMap
  lines.push("");
  lines.push("/**");
  lines.push(" * Global command map - merge all command namespaces");
  lines.push(" */");

  if (namespaceCommands.length > 0) {
    const allInterfaces = namespaceCommands
      .map((ns) => ns.interfaceName)
      .join(", ");
    lines.push(`export interface CommandMap extends ${allInterfaces} {}`);
  } else {
    lines.push("export interface CommandMap {}");
  }

  return lines.join("\n") + "\n";
}
