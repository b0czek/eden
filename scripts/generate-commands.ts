/**
 * Command and Event Type Generator
 *
 * Scans TypeScript files for @EdenHandler and @EdenNamespace decorators
 * and automatically generates command and event interfaces.
 *
 * Usage: ts-node scripts/generate-commands.ts
 */

import { Project, SyntaxKind, ClassDeclaration, Node, JSDoc } from "ts-morph";
import * as path from "path";
import * as fs from "fs";

interface CommandInfo {
  namespace: string;
  command: string;
  argsType: string;
  returnType: string;
  docs: string[];
}

interface NamespaceCommands {
  namespace: string;
  interfaceName: string;
  commands: Array<{
    command: string;
    argsType: string;
    returnType: string;
    docs: string[];
  }>;
}

interface EventInfo {
  namespace: string;
  eventName: string;
  payloadType: string;
  docs: string[];
}

interface NamespaceEvents {
  namespace: string;
  interfaceName: string;
  events: Array<{ eventName: string; payloadType: string; docs: string[] }>;
}

/**
 * Replace custom type references with inline imports
 */
function replaceTypesWithInlineImports(
  typeExpression: string,
  exportedTypes: Set<string>
): string {
  // Replace custom types with inline imports
  // Match capitalized identifiers that look like type names
  return typeExpression.replace(/\b([A-Z][a-zA-Z0-9]*)\b/g, (match) => {
    if (exportedTypes.has(match)) {
      return `import("./index").${match}`; // Replace with inline import
    }
    return match; // Keep as-is (built-in or local)
  });
}

/**
 * Extract JSDoc comments from a node
 */
function extractDocs(node: Node): string[] {
  if (Node.isJSDocable(node)) {
    return node.getJsDocs().map((doc) => doc.getInnerText());
  }
  return [];
}

/**
 * Generate TypeScript event interface code
 */
function generateEventCode(
  namespaceEvents: NamespaceEvents[],
  exportedTypes: Set<string>
): string {
  const lines: string[] = [];

  lines.push("/**");
  lines.push(" * AUTO-GENERATED FILE - DO NOT EDIT");
  lines.push(" * ");
  lines.push(
    " * This file is automatically generated by scripts/generate-commands.ts"
  );
  lines.push(" * Run 'pnpm run codegen' to regenerate.");
  lines.push(" */");
  lines.push("");

  // Generate interface for each namespace
  namespaceEvents.forEach((ns, index) => {
    lines.push("/**");
    lines.push(
      ` * ${ns.interfaceName} - Events for the "${ns.namespace}" namespace`
    );
    lines.push(" */");
    lines.push(`export interface ${ns.interfaceName} {`);

    ns.events.forEach((evt) => {
      // Add JSDoc if present
      if (evt.docs.length > 0) {
        lines.push("  /**");
        evt.docs.forEach((doc) => {
          lines.push(`   * ${doc.replace(/\n/g, "\n   * ")}`);
        });
        lines.push("   */");
      }

      // Replace type references with inline imports
      const payloadType = replaceTypesWithInlineImports(
        evt.payloadType,
        exportedTypes
      );
      lines.push(`  "${ns.namespace}/${evt.eventName}": ${payloadType};`);
    });

    lines.push("}");

    if (index < namespaceEvents.length - 1) {
      lines.push("");
    }
  });

  // Generate AppEvents interface
  lines.push("");
  lines.push("/**");
  lines.push(" * Global event map - merge all event namespaces");
  lines.push(" */");

  if (namespaceEvents.length > 0) {
    const allInterfaces = namespaceEvents
      .map((ns) => ns.interfaceName)
      .join(", ");
    lines.push(`export interface AppEvents extends ${allInterfaces} {}`);
  } else {
    lines.push("export interface AppEvents {}");
  }

  return lines.join("\n") + "\n";
}

/**
 * Generate TypeScript interface code
 */
function generateInterfaceCode(
  namespaceCommands: NamespaceCommands[],
  exportedTypes: Set<string>
): string {
  const lines: string[] = [];

  lines.push("/**");
  lines.push(" * AUTO-GENERATED FILE - DO NOT EDIT");
  lines.push(" * ");
  lines.push(
    " * This file is automatically generated by scripts/generate-commands.ts"
  );
  lines.push(" * Run 'npm run codegen' to regenerate.");
  lines.push(" */");
  lines.push("");

  // Generate interface for each namespace
  namespaceCommands.forEach((ns, index) => {
    lines.push("/**");
    lines.push(
      ` * ${ns.interfaceName} - Commands for the "${ns.namespace}" namespace`
    );
    lines.push(" */");
    lines.push(`export interface ${ns.interfaceName} {`);

    ns.commands.forEach((cmd) => {
      // Add JSDoc if present
      if (cmd.docs.length > 0) {
        lines.push("  /**");
        cmd.docs.forEach((doc) => {
          lines.push(`   * ${doc.replace(/\n/g, "\n   * ")}`);
        });
        lines.push("   */");
      }

      // Replace type references with inline imports
      const argsType = replaceTypesWithInlineImports(
        cmd.argsType,
        exportedTypes
      );
      const returnType = replaceTypesWithInlineImports(
        cmd.returnType,
        exportedTypes
      );

      lines.push(`  "${ns.namespace}/${cmd.command}": {`);
      lines.push(`    args: ${argsType};`);
      lines.push(`    response: ${returnType};`);
      lines.push(`  };`);
    });

    lines.push("}");

    if (index < namespaceCommands.length - 1) {
      lines.push("");
    }
  });

  // Generate CommandMap
  lines.push("");
  lines.push("/**");
  lines.push(" * Global command map - merge all command namespaces");
  lines.push(" */");

  if (namespaceCommands.length > 0) {
    const allInterfaces = namespaceCommands
      .map((ns) => ns.interfaceName)
      .join(", ");
    lines.push(`export interface CommandMap extends ${allInterfaces} {}`);
  } else {
    lines.push("export interface CommandMap {}");
  }

  return lines.join("\n") + "\n";
}

/**
 * Generate JavaScript file with runtime arrays
 */
function generateRuntimeJS(
  namespaceCommands: NamespaceCommands[],
  namespaceEvents: NamespaceEvents[]
): string {
  const lines: string[] = [];

  lines.push("/**");
  lines.push(" * AUTO-GENERATED FILE - DO NOT EDIT");
  lines.push(" * ");
  lines.push(
    " * This file contains runtime arrays for command and event names."
  );
  lines.push(" * Generated by scripts/generate-commands.ts");
  lines.push(" * Run 'pnpm run codegen' to regenerate.");
  lines.push(" */");
  lines.push("");
  lines.push("// Command names array");
  lines.push("export const COMMAND_NAMES = [");

  namespaceCommands.forEach((ns) => {
    ns.commands.forEach((cmd) => {
      lines.push(`  "${ns.namespace}/${cmd.command}",`);
    });
  });

  lines.push("];");
  lines.push("");
  lines.push("// Event names array");
  lines.push("export const APP_EVENT_NAMES = [");

  namespaceEvents.forEach((ns) => {
    ns.events.forEach((evt) => {
      lines.push(`  "${ns.namespace}/${evt.eventName}",`);
    });
  });

  lines.push("];");

  return lines.join("\n") + "\n";
}

/**
 * Generate TypeScript declaration file for runtime arrays
 */
function generateRuntimeDTS(): string {
  const lines: string[] = [];

  lines.push("/**");
  lines.push(" * AUTO-GENERATED FILE - DO NOT EDIT");
  lines.push(" * ");
  lines.push(" * Type declarations for runtime arrays.");
  lines.push(" * Generated by scripts/generate-commands.ts");
  lines.push(" * Run 'pnpm run codegen' to regenerate.");
  lines.push(" */");
  lines.push("");
  lines.push("// Command names array");
  lines.push("export declare const COMMAND_NAMES: readonly string[];");
  lines.push("");
  lines.push("// Event names array");
  lines.push("export declare const APP_EVENT_NAMES: readonly string[];");

  return lines.join("\n") + "\n";
}

/**
 * Extract command handlers from a class
 */
function extractCommandHandlers(
  classDec: ClassDeclaration,
  namespace: string
): CommandInfo[] {
  const commands: CommandInfo[] = [];

  classDec.getMethods().forEach((method) => {
    const commandDecorator = method.getDecorator("EdenHandler");
    if (commandDecorator) {
      const args = commandDecorator.getArguments();
      if (args.length > 0 && Node.isStringLiteral(args[0])) {
        const commandName = args[0].getLiteralText();

        // Extract argument type from first parameter
        let argsType = "Record<string, never>";
        const params = method.getParameters();
        if (params.length > 0) {
          const param = params[0];
          const typeNode = param.getTypeNode();
          if (typeNode) {
            let rawType = typeNode.getText();

            // Filter out properties starting with underscore (like _callerAppId)
            // This handles simple object literal types like { key: string; _callerAppId: string }
            argsType = rawType
              .replace(/[;,]\s*_\w+\s*:\s*[^;,}]+/g, "")
              .replace(/{\s*_\w+\s*:\s*[^;,}]+\s*[;,]?\s*/g, "{ ")
              .replace(/[;,]\s*}/g, " }")
              .trim();
          }
        }

        // Extract return type
        let returnType = "any";
        const returnTypeNode = method.getReturnTypeNode();
        if (returnTypeNode) {
          // Check if it's a Promise
          const type = returnTypeNode.getType();
          const symbol = type.getSymbol();
          if (symbol && symbol.getName() === "Promise") {
            const typeArgs = type.getTypeArguments();
            if (typeArgs.length > 0) {
              // Get the first type argument of the Promise
              // We need the text representation of the type argument
              // But getText() on the type object might return fully qualified names or aliases
              // It's safer to try to get the type node from the return type node if possible
              if (Node.isTypeReference(returnTypeNode)) {
                const typeArgsNodes = returnTypeNode.getTypeArguments();
                if (typeArgsNodes.length > 0) {
                  returnType = typeArgsNodes[0].getText();
                } else {
                  returnType = "void"; // Promise<void> -> void (or any)
                }
              } else {
                // Fallback to regex if AST navigation fails for some reason
                const typeText = returnTypeNode.getText();
                const match = typeText.match(/Promise<(.+)>/);
                if (match) {
                  returnType = match[1];
                } else {
                  returnType = typeText;
                }
              }
            }
          } else {
            returnType = returnTypeNode.getText();
          }
        }

        commands.push({
          namespace,
          command: commandName,
          argsType,
          returnType,
          docs: extractDocs(method),
        });
      }
    }
  });

  return commands;
}

/**
 * Extract event declarations from a class
 */
function extractEventDeclarations(
  classDec: ClassDeclaration,
  namespace: string
): EventInfo[] {
  const events: EventInfo[] = [];
  let eventsInterfaceName: string | null = null;

  // Check decorator arguments for events interface
  const namespaceDecorator = classDec.getDecorator("EdenNamespace");
  if (namespaceDecorator) {
    const args = namespaceDecorator.getArguments();
    // Second argument is options object
    if (args.length > 1 && Node.isObjectLiteralExpression(args[1])) {
      const eventsProperty = args[1].getProperty("events");
      if (eventsProperty && Node.isPropertyAssignment(eventsProperty)) {
        const initializer = eventsProperty.getInitializer();
        if (initializer && Node.isStringLiteral(initializer)) {
          eventsInterfaceName = initializer.getLiteralText();
        }
      }
    }
  }

  // Extract events interface from extends EdenEmitter<InterfaceName>
  if (!eventsInterfaceName) {
    const heritageClauses = classDec.getHeritageClauses();
    for (const clause of heritageClauses) {
      if (clause.getToken() === SyntaxKind.ExtendsKeyword) {
        for (const type of clause.getTypeNodes()) {
          const expression = type.getExpression();
          if (
            Node.isIdentifier(expression) &&
            expression.getText() === "EdenEmitter"
          ) {
            const typeArgs = type.getTypeArguments();
            if (typeArgs.length > 0) {
              const typeArg = typeArgs[0];
              if (Node.isTypeReference(typeArg)) {
                eventsInterfaceName = typeArg.getTypeName().getText();
              }
            }
          }
        }
      }
    }
  }

  // If we found an events interface name, find the interface definition
  if (eventsInterfaceName) {
    const sourceFile = classDec.getSourceFile();
    const interfaceDec = sourceFile.getInterface(eventsInterfaceName);

    if (interfaceDec) {
      interfaceDec.getProperties().forEach((prop) => {
        const nameNode = prop.getNameNode();
        if (Node.isStringLiteral(nameNode) || Node.isIdentifier(nameNode)) {
          const eventName = prop.getName();

          let cleanEventName = eventName;
          if (cleanEventName.startsWith('"') && cleanEventName.endsWith('"')) {
            cleanEventName = cleanEventName.slice(1, -1);
          } else if (
            cleanEventName.startsWith("'") &&
            cleanEventName.endsWith("'")
          ) {
            cleanEventName = cleanEventName.slice(1, -1);
          }

          let payloadType = "any";
          const typeNode = prop.getTypeNode();
          if (typeNode) {
            payloadType = typeNode.getText();
          }

          events.push({
            namespace,
            eventName: cleanEventName,
            payloadType,
            docs: extractDocs(prop),
          });
        }
      });
    }
  }

  return events;
}

/**
 * Main execution function
 */
export function generateCommands() {
  console.log("üîç Scanning for @EdenHandler and @EdenNamespace decorators...");

  const projectRoot = path.resolve(__dirname, "..");
  const srcDir = path.join(projectRoot, "src", "main");
  const typesDir = path.join(projectRoot, "src", "types");

  const project = new Project({
    skipAddingFilesFromTsConfig: true,
  });

  // Add source files
  project.addSourceFilesAtPaths([
    path.join(srcDir, "**/*.ts"),
    path.join(typesDir, "index.d.ts"),
  ]);

  console.log(`Found ${project.getSourceFiles().length} TypeScript files`);

  // Get exported types from src/types/index.d.ts
  const exportedTypes = new Set<string>();
  const indexFile = project.getSourceFile(path.join(typesDir, "index.d.ts"));
  if (indexFile) {
    indexFile.getExportedDeclarations().forEach((_, name) => {
      exportedTypes.add(name);
    });
    console.log(`Found ${exportedTypes.size} exported types from index.d.ts`);
  }

  const allCommands: CommandInfo[] = [];
  const allEvents: EventInfo[] = [];

  project.getSourceFiles().forEach((sourceFile) => {
    // Skip src/types/index.ts for command extraction
    if (sourceFile.getFilePath() === indexFile?.getFilePath()) return;

    sourceFile.getClasses().forEach((classDec) => {
      const namespaceDecorator = classDec.getDecorator("EdenNamespace");
      if (namespaceDecorator) {
        const args = namespaceDecorator.getArguments();
        if (args.length > 0 && Node.isStringLiteral(args[0])) {
          const namespace = args[0].getLiteralText();

          const commands = extractCommandHandlers(classDec, namespace);
          const events = extractEventDeclarations(classDec, namespace);

          allCommands.push(...commands);
          allEvents.push(...events);

          if (commands.length > 0) {
            console.log(
              `  ‚úì ${path.relative(projectRoot, sourceFile.getFilePath())}: ${
                commands.length
              } commands`
            );
          }
          if (events.length > 0) {
            console.log(
              `  ‚úì ${path.relative(projectRoot, sourceFile.getFilePath())}: ${
                events.length
              } events`
            );
          }
        }
      }
    });
  });

  console.log(`\nüì¶ Found ${allCommands.length} total command handlers`);
  console.log(`üì¶ Found ${allEvents.length} total event declarations`);

  // Group by namespace
  const namespaceMap = new Map<string, NamespaceCommands>();
  allCommands.forEach((cmd) => {
    if (!namespaceMap.has(cmd.namespace)) {
      const interfaceName =
        cmd.namespace
          .split("-")
          .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
          .join("") + "Commands";
      namespaceMap.set(cmd.namespace, {
        namespace: cmd.namespace,
        interfaceName,
        commands: [],
      });
    }
    namespaceMap.get(cmd.namespace)!.commands.push({
      command: cmd.command,
      argsType: cmd.argsType,
      returnType: cmd.returnType,
      docs: cmd.docs,
    });
  });
  const namespaceCommands = Array.from(namespaceMap.values());

  console.log(
    `üìã Grouped commands into ${namespaceCommands.length} namespaces:`
  );
  namespaceCommands.forEach((ns) => {
    console.log(`  - ${ns.namespace}: ${ns.commands.length} commands`);
  });

  const eventNamespaceMap = new Map<string, NamespaceEvents>();
  allEvents.forEach((evt) => {
    if (!eventNamespaceMap.has(evt.namespace)) {
      const interfaceName =
        evt.namespace
          .split("-")
          .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
          .join("") + "Events";
      eventNamespaceMap.set(evt.namespace, {
        namespace: evt.namespace,
        interfaceName,
        events: [],
      });
    }
    eventNamespaceMap.get(evt.namespace)!.events.push({
      eventName: evt.eventName,
      payloadType: evt.payloadType,
      docs: evt.docs,
    });
  });
  const namespaceEvents = Array.from(eventNamespaceMap.values());

  console.log(`üìã Grouped events into ${namespaceEvents.length} namespaces:`);
  namespaceEvents.forEach((ns) => {
    console.log(`  - ${ns.namespace}: ${ns.events.length} events`);
  });

  // Generate commands code
  const commandsCode = generateInterfaceCode(namespaceCommands, exportedTypes);
  const commandsOutputPath = path.join(
    projectRoot,
    "src",
    "types",
    "commands.generated.d.ts"
  );
  fs.writeFileSync(commandsOutputPath, commandsCode);
  console.log(
    `\n‚úÖ Generated ${path.relative(projectRoot, commandsOutputPath)}`
  );

  // Generate events code
  const eventsCode = generateEventCode(namespaceEvents, exportedTypes);
  const eventsOutputPath = path.join(
    projectRoot,
    "src",
    "types",
    "events.generated.d.ts"
  );
  fs.writeFileSync(eventsOutputPath, eventsCode);
  console.log(`‚úÖ Generated ${path.relative(projectRoot, eventsOutputPath)}`);

  // Generate runtime JS + d.ts pair
  const runtimeJSCode = generateRuntimeJS(namespaceCommands, namespaceEvents);
  const runtimeJSOutputPath = path.join(
    projectRoot,
    "src",
    "types",
    "runtime.generated.js"
  );
  fs.writeFileSync(runtimeJSOutputPath, runtimeJSCode);
  console.log(
    `‚úÖ Generated ${path.relative(projectRoot, runtimeJSOutputPath)}`
  );

  const runtimeDTSCode = generateRuntimeDTS();
  const runtimeDTSOutputPath = path.join(
    projectRoot,
    "src",
    "types",
    "runtime.generated.d.ts"
  );
  fs.writeFileSync(runtimeDTSOutputPath, runtimeDTSCode);
  console.log(
    `‚úÖ Generated ${path.relative(projectRoot, runtimeDTSOutputPath)}`
  );
}
